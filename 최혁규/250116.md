

## useEffect

```jsx
useEffect(() => {
  // 실행할 코드
}, [의존성 배열]);
```

### **동작**
1. **처음 렌더링 시** 실행
2. **의존성 배열의 값이 변경될 때마다** 실행
3. 의존성 배열이 비어 있으면 (`[]`), **초기 렌더링 시 한 번만** 실행

## clean-up

`useEffect`에서 반환된 함수는 **clean-up 함수**로, 다음 상황에서 실행
- 컴포넌트가 언마운트될 때
- `useEffect`가 다시 실행되기 전에 이전 effect를 정리(clean-up)할 때

### 필요성
clean-up 함수는 리소스 누수를 방지하거나, 중복 작업을 피하기 위해 사용
- 타이머 제거
- 이벤트 리스너 제거
- 구독 해제 등

### clean-up 함수의 사용 방법
`useEffect` 내부에서 함수 형태로 반환

```jsx
useEffect(() => {
  console.log('Effect 실행');

  return () => {
    console.log('Clean-up 실행');
  };
}, [의존성 배열]);
```

### **동작**
- **의존성 배열이 변경될 때**: 기존 effect가 정리되고 새로운 effect가 실행
- **컴포넌트 언마운트 시**: clean-up 함수가 호출

## 실습

### **(1) 타이머 예제**
컴포넌트가 언마운트되면 타이머를 정리(clean-up)하는 코드:
```jsx
import React, { useState, useEffect } from 'react';

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('타이머 시작');
    const timer = setInterval(() => {
      setCount((prev) => {
        const newCount = prev + 1;
        console.log(`현재 카운트: ${newCount}`);
        return newCount;
      });
    }, 1000);

    // clean-up 함수: 타이머 정리
    return () => {
      clearInterval(timer);
      console.log('타이머 정리됨');
    };
  }, []); // 한 번만 실행

  return <div>타이머: {count}초</div>;
}

export default Timer;
```

#### console 출력
1. 컴포넌트가 처음 렌더링될 때:
   ```
   타이머 시작
   현재 카운트: 1
   현재 카운트: 2
   현재 카운트: 3
   ...
   ```
2. 컴포넌트가 언마운트될 때:
   ```
   타이머 정리됨
   ```

## 주의점
- `clean-up 함수`는 항상 이전 effect를 정리(clean-up)한 뒤 새로운 effect를 실행
- 의존성 배열(`[]`)을 적절히 설정하지 않으면 **의도치 않은 재실행**이 발생할 수 있음

## 정리
- `useEffect`는 컴포넌트가 렌더링될 때 **사이드 이펙트 처리**를 수행
- clean-up 함수는 **리소스 정리 및 누수 방지**를 위해 사용
- 효과적으로 사용하려면 **의존성 배열**과 함께 정확히 관리해야함함
