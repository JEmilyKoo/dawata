# 250113 숙제 1일차 (도커)

## Docker

- Docker는 애플리케이션을 컨테이너(Container)라는 가상 환경에서 실행하기 위한 플랫폼 입니다. 이 컨테이너는 애플리케이션의 실행에 필요한 모든 코드, 라이브러리, 설정 파일 등을 포함하고 있어, 개발 환경과 운영 환경의 차이를 없애고, 이식성과 일관성을 보장합니다.
- Docker는 컨테이너 기술을 기반으로 하며, 가상 머신(VM)과 달리 운영체제(OS) 커널을 공유하므로 더 가볍고 빠릅니다. 이를 통해 애플리케이션 개발, 테스트, 배포 프로세스를 단순화하고 효율화할 수 있습니다.
    
    (추가 : 가상 머신은 이와 반대로 각각 자체 운영체제를 포함. 즉, VM마다 독립적인 커널과 시스템 파일을 가짐. 또한, VM은 호스트 운영체제 위에 하이퍼바이저라는 소프트웨어를 사용해 물리적 하드웨어를 가상화하며, 이 하이퍼바이저는 물리적 리소스를 여러 VM에 나눠 줌. 이로 인해 완전한 격리가 가능하고 운영체제가 다를 경우 적합하지만, 무겁고 속도가 느리고 복잡하다는 단점이 있음.)
    
    |  | Docker (컨테이너) | VM 가상머신 |
    | --- | --- | --- |
    | 운영체제 공유 | 호스트 OS의 커널을 공유 | 각 VM이 독립적인 OSfmf tlfgod |
    | 리소스 사용량 | 가볍고 효율적 | 무겁고 많은 리소스 필요 |
    | 시작 속도 | 수 밀리초 | 수 분 |
    | 이식성 | 동일한 환경에서 실행 가능 | 설정과 환경에 따라 실행이 어려움 |
- 네이티브와 도커 비교

|  | Docker | 네이티브 |
| --- | --- | --- |
| 실행 환경 | 컨테이너(운영체제 위의 가상화 계층) | 운영체제 위에서 직접 실행 |
| 이식성 | 높음(Docker 이미지는 어디서든 실행 가능) | 낮음 (OS나 환경이 달라지면 실행 어려움) |
| 성능 | 약간의 오버헤드 (컨테이너 격리로 인해) | 최적화된 성능 (직접 실행) |
| 환경 독립성 | 환경에 의존하지 않음 | 환경에 따라 결과가 달라질 수 있음 |
| 설정 복잡도 | 초기 설정이 필요(Dockerfile작성,이미지 빌드) | OS에 따라 바로 실행 가능 (단, 의존성 관리 필요) |
| 사용 목적 | 여러 환경에서 일관성 있는 실행을 원할 때 | 특정 OS에서 최적화된 실행을 원할 때 |

- 그럼 우린 팀원 모두가 윈도우를 쓰는 동일한 환경인데 왜 굳이 네이티브가 아니라 wsl을 설치하여 도커를 사용해?
    - 제공 받는 EC2 서버가 하나로 Linux 기반의 서버임.
    - 팀원 모두가 Windows를 사용하더라도, Docker 컨테이너는 Linux 환경에서 실행되므로 최종 배포 환경과 동일한 설정으로 개발 가능
    - 개발 환경과 배포 환경 간 차이를 없애줌
    - Docker 이미지는 어디서나 실행 가능하므로, 팀원 간 환경 설정 문제가 발생하지 않음
    - CI/CD 파이프라인에서 Docker 이미지를 사용해 자동 배포 가능
    - 현업에선 도커로 개발하는 경우가 더 많기 때문에 경험할 수 있음
    - 그러나, 우리는 윈도우 위에 wsl을 올려 사용하는데, wsl은 램 사용량이 많아질 수 있어 도커와 함께 애플리케이션 실행 시 성능 저하나 튕길 수 있음. (해결책은 내일 ..!)

### Docker 이미지(Image)란?

- Docker 이미지는 컨테이너는 실행하기 위한 설치 패키지 또는 템플릿입니다.
- 애플리케이션 실행에 필요한 코드, 라이브러리, 설정 파일 등을 포함합니다.
- **불변성** : 컨테이너를 실행하기 전 단계의 상태로, 불변하며 읽기 전용입니다.  즉, Docker 이미지는 한 번 생성되면 변경할 수 없으며, 새로운 이미지 레이어를 추가하여 변경 사항을 반영해야 합니다(**불변성**). 이미지는 기본적으로 **읽기 전용 파일 시스템으로 구성되어 컨테이너 실행 시 이미지 자체가 변경되지 않도록 보호**합니다. 컨테이너를 실행할 때, 이미지의 읽기 전용 파일 시스템 위에 읽기-쓰기 가능한 임시 레이어가 생성됩니다. 컨테이너가 실행 중에 생성한 파일이나 데이터는 이 임시 레이어에 저장되며, 컨테이너가 삭제되면 사라집니다.
- **계층 구조**: 이미지 파일을 여러 층(레이어)로 구성됩니다. 각 레이어는 이전 레이어 위에 덧붙여지는 형태로, 변경 사항이 최소화됩니다.
- 생성 방법 : Docker 이미지는 주로 Dockerfile을 작성하여 빌드합니다.
    
    `FROM ubuntu:20.04`
    
    `RUN apt-get update && apt-get install -y python3`
    
    `COPY [app.py](http://app.py) /app/app.py`
    
    `CMD [”python3”, “/app/app.py”]`
    
    FROM : 기본 이미지 정의
    
    RUN : 명령 실행
    
    COPY : 파일 복사
    
    CMD : 컨테이너 실행 시 실행될 명령어
    
- Q) 왜 불변성과 읽기 전용을 지키려고 할까..?
    
    A)
    
    1. 일관성 보장 : 동일한 이미지를 사용하는 컨테이너는 항상 같은 상태로 실행됩니다. 변경 가능한 이미지라면 실행 환경이 달라질 수 있어, 개발, 테스트, 운영 간 일관성이 깨질 위험이 있습니다.
    2. 캐싱 및 효율성 : 이미지 레이어는 읽기 전용으로 설계되어 재사용이 가능합니다. 동일한 레이어를 사용하는 다른 이미지나 컨테이너는 추가적으로 저장 공간을 소모하지 않습니다. 덕분에 Docker는 이미지를 더 효율적으로 관리할 수 있습니다. 
    3. 보안성 : 이미지가 변경되지 않도록 보호하므로, 실행 중이거나 배포된 이미지에 의도치 않은 수정이 발생하지 않습니다. 

### Docker 컨테이너(Container)란?

- Docker 컨테이너는 이미지 기반으로 실행중인 프로세스입니다.
- 이미지에서 생성되며, 실제로 애플리케이션이 실행되는 가상 환경입니다.
- 독립성 : 컨테이너는 서로 독립적으로 실행되며, 호스트 환경과 격리된 상태에서 작동합니다.
- 읽기-쓰기 가능 : 컨테이너는 이미지를 읽기 전용으로 사용하지만, 실행 중 변경된 내용은 컨테이너 레이어에 저장됩니다.
- 생성 방법 : 이미지를 기반으로 컨테이너를 실행합니다.
    
    `docker run -it ubuntu:20.04`
    
    docker run : 컨테이너 생성 및 실행 
    
    -it : 인터랙티브 모드
    
    ubuntu:20.04 : 사용할 이미지
    

### 이미지와 컨테이너의 차이

| 구분 | 이미지 | 컨테이너 |
| --- | --- | --- |
| 상태 | 정적(Static) | 동적(Dynamic) |
| 역할 | 컨테이너를 생성하기 위한 템플릿 | 이미지로부터 생성된 실행 환경 |
| 파일 시스템 | 읽기 전용 | 읽기-쓰기 가능 |
| 생성 방법 | Dockerfile을 통해 빌드 | docker run으로 이미지 실행 |
| 사용 목적 | 컨테이너 실행 준비 | 애플리케이션 실행 |

### 이미지와 컨테이너를 함께 사용하는 이유

- 효율성 : 이미지는 한 번 빌드되면 동일한 상태를 유지하므로, 컨테이너를 빠르게 생성 가능
- 확장성 : 동일한 이미지를 사용해 여러 개의 컨테이너 실행 가능
- 버전 관리 : 이미지 버전을 관리하면 특정 환경에서 항상 동일하게 실행 가능.

### Docker 실행을 위한 과정

1. Docker 설치 준비 : 도커는 기본적으로 리눅스 커널 위에서 동작하므로, 이번 프로젝트에선 윈도우로 진행하기 때문에 리눅스 환경이 추가적으로 필요했습니다. 이를 위해 WSL(Windows Subsystem for Linux)을 설치했습니다.
2. Docker Desktop 설치
3. Docker와 WSL 통합 : Docker Desktop 설정에서 WSL 통합 옵션 활성화

### Docker의 장점

1. 일관성 보장 
    
    개발, 테스트, 배포 환경 간 차이를 없앰
    
2. 효율성
    
    컨테이너는 운영체제 커널을 공유하여 리소스를 적게 소모하고, 시작 속도가 빠름.
    
3. 이식성 
    
    “Build once, run anywhere” 철학에 따라 Docker 이미지는 어디서든 실행 가능.
    
4. 확장성
    
    동일한 이미지를 사용해 여러 컨테이너를 실행 가능
    
    마이크로서비스 아키텍처에 적합
    
5. 자동화 용이
    
    CI/CD 파이프라인에서 쉽게 통합 가능
    
6. 버전 관리
    
    이미지로 환경과 애플리케이션 버전을 관리 가능
    

### Docker의 단점

1. 학습 곡선
    
    Dockerfile 작성, 네트워크 설정 등 초기 학습이 필요
    
2. 운영체제 의존성
    
    Linux 기반 기술로, Windows에서는 WSL 등 추가 계층 필요
    
3. 보안 문제
    
    컨테이너 간 커널 공유로 보안 취약점 발생 가능
    
4. 복잡성 증가
    
    컨테이너 오케스트레이션(쿠버네티스 등)을 추가로 도입하면 관리 복잡도가 증가
    
- 오늘의 궁금증 : 도커 컨테이너에서 사용 중인 포트와 로컬 머신에서 사용 중인 포트가 일치할 경우엔 어떻게 되나요? 서버가 작동하는 방식은 **포트 매핑**에 의해 결정됨. 이를 통해 Docker는 컨테이너 내부의 포트를 로컬 머신(호스트)와 연결합니다. Docker에서 포트 매핑이란? Docker 컨테이너는 자체적으로 격리된 네트워크 환경에서 동작합니다. 컨테이너 내부의 특정 포트를 로컬 머신의 포트와 연결하여 외부에서 접근 가능하도록 설정합니다. (Docker 내부의 3306 포트를 로컬의 3306 포트와 매핑).  포트 번호가 일치할 경우 컨테이너에서 포트를 매핑했을 경우, Docker의 네트워크 격리 덕에 포트 충돌 없이 작동합니다. (즉, 컨테이너의 서버가 응답). 만약 로컬 머신의 3306 포트에서 이미 다른 프로세스가 실행 중이라면, Docker는 해당 포트를 사용할 수 없으므로 실행 오류가 발생합니다. 같은 호스트 포트를 여러 컨테이너에서 매핑하려 하면 충돌이 발생합니다.